<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Query Latency Over Time</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        a:hover {
            text-decoration: underline;
        }
        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 18px;
            font-weight: 600;
            color: #555;
            margin-bottom: 15px;
        }
        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            font-size: 14px;
            color: #666;
        }
        .stat-item {
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .stat-label {
            font-weight: 600;
            margin-right: 5px;
        }
        .result-type-selector {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .result-type-selector label {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 10px;
            cursor: pointer;
            font-size: 14px;
        }
        .result-type-selector input[type="radio"] {
            margin-right: 8px;
            cursor: pointer;
        }
        .result-type-selector h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            color: #555;
        }
        .zoom-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .zoom-button {
            padding: 6px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .zoom-button:hover {
            background: #0056b3;
        }
        .zoom-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .zoom-info {
            font-size: 12px;
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>turbopuffer text search nightly benchmarks</h1>
        <p style="margin-bottom: 20px;"><a href="2025-12-12T10-51-19/index.html" style="color: #007bff; text-decoration: none; font-size: 14px;">See most recent comparison against Lucene and Tantivy</a></p>
        <div class="result-type-selector">
            <h2>Result Type:</h2>
            <label><input type="radio" name="resultType" value="TOP_10" checked> TOP_10</label>
            <label><input type="radio" name="resultType" value="TOP_100" > TOP_100</label>
            <label><input type="radio" name="resultType" value="TOP_1000" > TOP_1000</label>
            <label><input type="radio" name="resultType" value="TOP_100_FILTER_20%" > TOP_100_FILTER_20%</label>
            <label><input type="radio" name="resultType" value="TOP_100_FILTER_5%" > TOP_100_FILTER_5%</label>
            <label><input type="radio" name="resultType" value="TOP_100_FILTER_80%" > TOP_100_FILTER_80%</label>
        </div>

    <script>
        // Register zoom plugin when Chart.js is ready
        if (typeof Chart !== 'undefined') {
            // The zoom plugin from CDN should auto-register, but we'll ensure it's available
            Chart.defaults.set('plugins.zoom', {
                pan: {
                    enabled: true,
                    mode: 'x'
                },
                zoom: {
                    wheel: {
                        enabled: true
                    },
                    pinch: {
                        enabled: true
                    },
                    drag: {
                        enabled: true,
                        modifierKey: null
                    },
                    mode: 'x'
                }
            });
        }
        
        // Store all chart data for all result types
        const allChartData = {"TOP_10": {"the": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [4124, 2910, 3040, 2580, 3676, 16066, 15998, 3849, 2797, 2168, 2755, 2843, 2835, 2966, 2741, 2978, 2994, 2532, 3224, 3425, 3215]}, "search": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1235, 794, 1318, 765, 1355, 1966, 2019, 1230, 783, 906, 870, 937, 924, 916, 1025, 956, 942, 897, 999, 968, 1022]}, "new york": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [3335, 2259, 3016, 2635, 3415, 10213, 10046, 3504, 2733, 2439, 3113, 2833, 2724, 2721, 3016, 2958, 2951, 2599, 3059, 2977, 2782]}, "san francisco": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1958, 1323, 1899, 1405, 1879, 4356, 4317, 1859, 1395, 1483, 1627, 1519, 1524, 1554, 1646, 1571, 1595, 1539, 1552, 1518, 1552]}, "the who": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [4362, 3040, 3079, 3352, 4266, 32579, 32662, 4787, 3414, 2715, 3870, 3416, 3442, 3586, 3519, 3461, 3191, 2793, 3815, 3266, 3345]}, "the incredibles": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2629, 1505, 2071, 1804, 3179, 20900, 20540, 3249, 1886, 1585, 2159, 2165, 2132, 2252, 2336, 2179, 2216, 1829, 1768, 1892, 1795]}, "new york population": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [5666, 4023, 5532, 4065, 5617, 17447, 17667, 5539, 4222, 4069, 4944, 4196, 4468, 4322, 4304, 4507, 4528, 4048, 4241, 4342, 4029]}, "world bank president": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [3912, 2598, 3604, 3031, 3754, 11705, 12038, 3916, 3016, 2981, 3685, 3287, 3151, 3276, 3238, 3076, 3091, 2914, 3006, 3130, 2714]}, "united states constitution": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [3513, 2495, 2947, 2855, 3251, 10733, 10955, 3395, 2954, 2713, 3323, 3089, 3052, 3126, 3179, 3087, 2889, 2591, 2957, 2950, 3329]}, "lord of the rings": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [4323, 2846, 3346, 2701, 4154, 41239, 41259, 4444, 2889, 2074, 2920, 3025, 2866, 2895, 2954, 2966, 3136, 2158, 2900, 2944, 3912]}, "story of a girl": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [4813, 3363, 4855, 3720, 4876, 46095, 46318, 5051, 3689, 3326, 3938, 3806, 3863, 3396, 3778, 3854, 4062, 3482, 3753, 3893, 4863]}, "arsenal player 1998 forward goal non flying dutch": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [6750, 4625, 6476, 5352, 6831, 18104, 18399, 7002, 5078, 4710, 5694, 5070, 5502, 5783, 5335, 5363, 5317, 4895, 4859, 3769, 3684]}, "france president world war resistance london appeal": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [9962, 6718, 9451, 7514, 9523, 29470, 29967, 9942, 7483, 6878, 8186, 7346, 7831, 7811, 7382, 7668, 7357, 6791, 6930, 4784, 4562]}, "pop singer songwriter born 1989 won best country song time person of year": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [14893, 11039, 14401, 12618, 15418, 95453, 95717, 15478, 12088, 10183, 12593, 12036, 12769, 12875, 12095, 12154, 11748, 10427, 11045, 8823, 8570]}, "kenyan world marathon record olympic champion bbc world sport star of the year": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [10682, 6897, 9560, 8398, 10467, 79505, 80657, 11735, 8270, 7320, 8703, 8399, 9052, 8908, 9021, 8699, 8373, 7277, 8014, 6951, 6568]}, "a search engine is an information retrieval software system designed to help find information stored on one or more computer systems": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [17648, 12904, 16963, 14451, 19243, 188223, 188656, 18818, 14021, 11297, 14169, 13614, 13765, 13731, 12713, 14201, 13573, 10976, 12794, 11923, 12335]}, "law school rankings": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1806, 2698, 8634, 8455, 2519, 1928, 1818, 2374, 1972, 2101, 2090, 2154, 2118, 2130, 1756, 2002, 2250, 2364]}, "to be or not to be": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [13179, 16252, 57275, 57464, 16189, 13153, 11825, 15282, 13353, 13690, 13590, 13738, 13755, 13353, 11927, 13767, 13722, 13443]}, "a database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure indexes are used to quickly locate data without having to search every row in a database table every time said table is accessed": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [25013, 32791, 312949, 314950, 35143, 25914, 17708, 24957, 24191, 25536, 24614, 25117, 24999, 24628, 17638, 21717, 20802, 20955]}, "what is the name of the chemist who fully developed the aquarium principle in 1850 explaining that plants added to water in a container would give off enough oxygen to support animals as long as the number of animals did not grow too large": {"dates": ["2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [30014, 24569, 23222]}}, "TOP_100": {"the": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [5331, 3939, 4204, 3419, 4880, 16541, 16487, 5288, 3356, 3091, 3750, 3700, 3693, 3645, 3672, 3696, 3690, 3347, 4554, 4437, 4616]}, "search": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1876, 1254, 1793, 1251, 1850, 2335, 2385, 2141, 1279, 1313, 1414, 1467, 1445, 1433, 1337, 1435, 1407, 1394, 1398, 1436, 1606]}, "new york": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [4945, 3736, 4824, 4227, 5306, 10466, 10315, 6128, 4302, 3981, 5239, 4581, 4575, 4518, 4415, 4419, 4516, 4143, 4520, 4589, 4680]}, "san francisco": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2491, 1759, 2356, 1808, 2489, 4734, 4625, 2523, 1900, 1934, 2150, 2029, 2064, 2065, 2097, 2034, 2071, 1966, 2009, 1969, 1914]}, "the who": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [5975, 4392, 5027, 4835, 6281, 33182, 33691, 7413, 4676, 4063, 5197, 5113, 5004, 5225, 4892, 4564, 4796, 4314, 5300, 4576, 6212]}, "the incredibles": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [4464, 2937, 3657, 4058, 5237, 21031, 21450, 5733, 3759, 2977, 3926, 3969, 4122, 4277, 3988, 4237, 4502, 3515, 3419, 3419, 4125]}, "new york population": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [7203, 5428, 7218, 5447, 6916, 17930, 17552, 7424, 5178, 5247, 6237, 5530, 5652, 5533, 5370, 5585, 5617, 5241, 5209, 5155, 4235]}, "world bank president": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [5142, 3654, 4811, 4397, 5191, 12282, 12332, 5650, 4247, 4066, 5093, 4506, 4549, 4471, 4386, 4473, 4218, 4191, 4591, 3869, 3526]}, "united states constitution": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [4501, 3491, 4002, 3931, 4269, 11347, 11185, 4816, 3712, 3511, 4656, 4067, 4084, 4046, 4032, 4081, 3840, 3607, 3940, 3996, 4023]}, "lord of the rings": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [5776, 4007, 5050, 4213, 6190, 42014, 41701, 6631, 4273, 3261, 4921, 4881, 4793, 4747, 4382, 4401, 4885, 3684, 4780, 5049, 9597]}, "story of a girl": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [6809, 5231, 6798, 6009, 6959, 46635, 46601, 7708, 4711, 5214, 6155, 5826, 5636, 5770, 5570, 5480, 6013, 5380, 6052, 6109, 8756]}, "arsenal player 1998 forward goal non flying dutch": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [8055, 5686, 7837, 6501, 8380, 18794, 18674, 8597, 6165, 5727, 6710, 6124, 6612, 6785, 6299, 6549, 6333, 5923, 5803, 4634, 4247]}, "france president world war resistance london appeal": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [11410, 8055, 10717, 9767, 12675, 30198, 30188, 13096, 9097, 7653, 9566, 8508, 9328, 9453, 8456, 8690, 8521, 8057, 8061, 6277, 5486]}, "pop singer songwriter born 1989 won best country song time person of year": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [18933, 14129, 17786, 16411, 20602, 96101, 97014, 21706, 15617, 13105, 17129, 14472, 15700, 16272, 14823, 15157, 14443, 13375, 14239, 12068, 12250]}, "kenyan world marathon record olympic champion bbc world sport star of the year": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [15700, 10851, 14262, 12798, 17071, 80913, 80994, 17985, 12126, 10448, 13201, 11832, 12423, 12746, 11873, 12338, 12185, 10597, 11283, 9870, 9895]}, "a search engine is an information retrieval software system designed to help find information stored on one or more computer systems": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [25098, 19883, 24428, 22988, 27833, 188985, 189042, 29382, 20931, 17351, 22393, 20762, 21447, 21931, 20536, 21636, 20371, 17068, 20059, 19273, 20536]}, "law school rankings": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [3140, 3901, 8984, 9061, 3953, 3114, 3009, 3684, 3329, 3321, 3248, 3310, 3393, 3382, 3107, 3321, 3303, 3090]}, "to be or not to be": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [15778, 19063, 57657, 58258, 19028, 15213, 13903, 18166, 15858, 15716, 15872, 15439, 16219, 15196, 14229, 15827, 15805, 14559]}, "a database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure indexes are used to quickly locate data without having to search every row in a database table every time said table is accessed": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [38459, 46436, 317672, 314711, 50384, 36226, 27807, 38206, 35662, 36584, 37655, 34829, 37836, 35301, 28596, 33055, 33113, 34698]}, "what is the name of the chemist who fully developed the aquarium principle in 1850 explaining that plants added to water in a container would give off enough oxygen to support animals as long as the number of animals did not grow too large": {"dates": ["2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [40450, 35565, 33477]}}, "TOP_1000": {"the": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [13031, 9787, 11588, 8771, 12644, 18078, 18143, 12883, 8368, 8083, 10198, 9218, 8946, 9142, 9233, 8958, 8943, 8257, 10138, 9157, 10654]}, "search": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [4455, 2954, 4890, 3086, 4284, 3803, 3790, 4166, 2963, 3168, 3215, 3302, 3074, 3183, 3248, 3076, 2909, 2986, 3081, 3048, 3196]}, "new york": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [8337, 6259, 8524, 7128, 8979, 12019, 12264, 8715, 6855, 6728, 8049, 7230, 7197, 7218, 7195, 7134, 7095, 6451, 7004, 6814, 6165]}, "san francisco": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [4999, 3663, 5247, 3999, 5465, 6225, 6358, 5118, 3893, 3718, 4326, 4026, 4048, 3934, 4046, 4027, 3893, 3840, 3807, 3702, 3424]}, "the who": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [14598, 10890, 12735, 11154, 14647, 35051, 35108, 14627, 10733, 10084, 12747, 11915, 11424, 11132, 11475, 11116, 11139, 10521, 11445, 11454, 14363]}, "the incredibles": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [13175, 9337, 11755, 10186, 13652, 22802, 22737, 13754, 10582, 9045, 11561, 10514, 10418, 10728, 10607, 10581, 10144, 9503, 9317, 9363, 11100]}, "new york population": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [11933, 8905, 12063, 9012, 11858, 19408, 19808, 11934, 9080, 8567, 10531, 9405, 9329, 9242, 9388, 9257, 9139, 8428, 9111, 7390, 6386]}, "world bank president": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [9648, 6677, 9469, 7190, 9337, 13865, 14005, 9383, 7170, 6953, 8431, 7546, 7593, 7598, 7717, 7624, 7200, 6945, 7157, 6046, 5628]}, "united states constitution": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [8302, 6343, 8154, 6672, 8411, 12542, 13168, 8344, 6720, 6333, 7824, 6989, 6676, 6859, 6942, 6708, 6237, 6099, 6816, 6539, 6141]}, "lord of the rings": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [14353, 11617, 12975, 11374, 14339, 43448, 43989, 14940, 11600, 10219, 12923, 12368, 11853, 12022, 12509, 11975, 12017, 10067, 11772, 13500, 15414]}, "story of a girl": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [15132, 12319, 15424, 12645, 15539, 48018, 48426, 15285, 12216, 11984, 15099, 13050, 12598, 12803, 13433, 12781, 12753, 11696, 12955, 14109, 16297]}, "arsenal player 1998 forward goal non flying dutch": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [12394, 8916, 12762, 10040, 13523, 20390, 20516, 13498, 9564, 8888, 9977, 9469, 9946, 10057, 9623, 9832, 9222, 8893, 8574, 6571, 6022]}, "france president world war resistance london appeal": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [16987, 12145, 17002, 14333, 19031, 31520, 32165, 19251, 13876, 11791, 14354, 12532, 13555, 13994, 13068, 13152, 12459, 11876, 11206, 8818, 7802]}, "pop singer songwriter born 1989 won best country song time person of year": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [29821, 21930, 29276, 26364, 32329, 98050, 98784, 33427, 25763, 21581, 27707, 23451, 25319, 25560, 24419, 24779, 23711, 21997, 22291, 19030, 18237]}, "kenyan world marathon record olympic champion bbc world sport star of the year": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [27463, 19992, 25724, 23534, 29722, 81203, 82245, 30930, 22563, 18676, 23618, 21248, 21985, 22950, 22043, 21071, 21070, 18917, 20475, 16872, 17963]}, "a search engine is an information retrieval software system designed to help find information stored on one or more computer systems": {"dates": ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [44214, 36375, 42492, 40543, 47018, 190100, 192084, 48953, 39092, 34077, 44616, 38278, 38659, 40320, 39210, 39235, 37759, 34213, 37312, 34086, 33756]}, "law school rankings": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [6938, 8965, 10571, 10747, 8795, 6613, 6334, 7500, 6913, 7052, 7166, 7071, 6972, 6655, 6535, 6279, 5524, 4832]}, "to be or not to be": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [21828, 26437, 59123, 59669, 26233, 20827, 19640, 24594, 21540, 21726, 21744, 21726, 22000, 21064, 19553, 21572, 20810, 15084]}, "a database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure indexes are used to quickly locate data without having to search every row in a database table every time said table is accessed": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [69976, 81090, 316401, 319680, 82299, 68875, 57069, 74471, 66709, 68146, 70166, 67182, 68315, 65559, 57790, 64098, 60136, 60900]}, "what is the name of the chemist who fully developed the aquarium principle in 1850 explaining that plants added to water in a container would give off enough oxygen to support animals as long as the number of animals did not grow too large": {"dates": ["2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [65110, 56393, 54917]}}, "TOP_100_FILTER_20%": {"the": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1056, 10232, 28984, 29481, 11042, 7714, 7062, 8419, 7894, 7548, 7899, 8147, 8427, 8359, 7309, 8453, 7903, 8804]}, "search": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [604, 4767, 4026, 4241, 5299, 3563, 3027, 3577, 3143, 3339, 3686, 3187, 3797, 3575, 3139, 3092, 3142, 3491]}, "new york": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1017, 8866, 15028, 15405, 9459, 7070, 6137, 7471, 6515, 6845, 7344, 6639, 7449, 7216, 6145, 6606, 6378, 5612]}, "san francisco": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [781, 5603, 6968, 7232, 5944, 4200, 3547, 4368, 3844, 4110, 4403, 3981, 4436, 4182, 3744, 3550, 3631, 2674]}, "the who": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1503, 12123, 45543, 46355, 12775, 8878, 7949, 9607, 9703, 9135, 9176, 8757, 9045, 9055, 7928, 8860, 8324, 12263]}, "the incredibles": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1289, 10595, 33645, 33953, 11885, 8670, 7695, 9256, 9019, 8961, 9021, 9068, 9612, 9237, 7878, 7776, 7403, 8717]}, "new york population": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1041, 10032, 23004, 23418, 10465, 7909, 6725, 8394, 7307, 7585, 8146, 7475, 7993, 7978, 7031, 6969, 6340, 5492]}, "world bank president": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [966, 8165, 16494, 16779, 8796, 6569, 5859, 7198, 6312, 6463, 7052, 6467, 6866, 6566, 5939, 6081, 5655, 4584]}, "united states constitution": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1150, 7200, 14826, 15615, 7953, 5912, 5255, 6523, 5677, 5793, 6208, 5683, 6319, 6031, 5280, 5415, 5649, 5052]}, "law school rankings": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1012, 7718, 12237, 13125, 8311, 6076, 5556, 6578, 6015, 6225, 6679, 6222, 6945, 6526, 5572, 5602, 4981, 4027]}, "lord of the rings": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1812, 9292, 54692, 55310, 9881, 6664, 5321, 6831, 6582, 6873, 7235, 6817, 7342, 7374, 5586, 6506, 8502, 13044]}, "story of a girl": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1758, 10254, 59395, 59929, 10896, 7896, 7183, 8121, 7599, 7926, 8760, 7830, 8569, 8411, 7224, 7579, 8981, 13519]}, "to be or not to be": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1949, 23266, 67831, 68444, 24009, 19132, 17125, 21316, 18689, 19321, 19886, 18809, 19668, 18921, 17012, 18797, 18147, 14232]}, "arsenal player 1998 forward goal non flying dutch": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1475, 12513, 22054, 23145, 12874, 9266, 7717, 9178, 8262, 9261, 9650, 8596, 9564, 9065, 8005, 7651, 6056, 5174]}, "france president world war resistance london appeal": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1403, 16841, 34986, 35929, 17499, 12665, 10453, 12637, 11050, 12237, 13248, 11579, 12353, 11826, 10926, 10093, 7742, 6672]}, "pop singer songwriter born 1989 won best country song time person of year": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [3044, 24803, 109015, 109914, 26158, 19447, 15225, 19984, 17242, 18790, 19850, 17677, 18834, 17939, 15585, 16366, 13931, 14995]}, "kenyan world marathon record olympic champion bbc world sport star of the year": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2915, 22907, 93340, 94005, 24173, 17117, 13682, 16811, 15226, 16507, 17665, 15840, 16887, 16217, 13969, 14405, 11739, 13678]}, "a search engine is an information retrieval software system designed to help find information stored on one or more computer systems": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [5889, 32392, 202705, 202445, 33443, 25084, 20069, 25837, 23603, 24478, 26131, 24138, 25160, 23892, 19698, 22246, 21802, 27586]}, "a database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure indexes are used to quickly locate data without having to search every row in a database table every time said table is accessed": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [11582, 53949, 329664, 330028, 55452, 42395, 31763, 42162, 38831, 41222, 43501, 41336, 43193, 40417, 32988, 37006, 35673, 46464]}, "what is the name of the chemist who fully developed the aquarium principle in 1850 explaining that plants added to water in a container would give off enough oxygen to support animals as long as the number of animals did not grow too large": {"dates": ["2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [41529, 37622, 43085]}}, "TOP_100_FILTER_5%": {"the": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1050, 17913, 22787, 22958, 18573, 12964, 12917, 15404, 13974, 12755, 12985, 13690, 13246, 12945, 12718, 14796, 13805, 14260]}, "search": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [621, 4636, 4099, 4430, 4652, 3144, 2932, 3483, 3298, 3267, 3425, 3243, 3416, 3438, 3019, 3143, 3342, 3319]}, "new york": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [932, 8720, 13731, 13926, 8550, 6141, 5767, 7437, 6475, 6503, 6830, 6529, 6703, 6765, 5935, 6472, 6128, 5575]}, "san francisco": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [786, 5448, 6842, 7006, 5532, 3775, 3619, 4349, 3886, 3951, 4185, 3873, 4113, 4193, 3764, 3863, 3641, 2843]}, "the who": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1295, 16146, 39526, 39626, 15795, 11854, 10721, 13402, 12326, 11804, 11570, 12485, 11183, 11517, 10375, 12148, 11689, 14167]}, "the incredibles": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1207, 18830, 27667, 28017, 19467, 13661, 14163, 16608, 14575, 14390, 14600, 15127, 14568, 14280, 13676, 14247, 13272, 14198]}, "new york population": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1026, 10915, 20989, 21387, 10334, 7500, 7287, 8889, 7915, 8094, 8253, 8096, 8170, 8545, 7539, 7605, 6619, 5888]}, "world bank president": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [928, 9809, 15395, 15682, 9496, 6862, 6410, 8067, 7079, 7472, 7802, 7106, 7458, 7434, 6776, 7013, 5728, 4688]}, "united states constitution": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1127, 7893, 14260, 14598, 8234, 6103, 5620, 7081, 6377, 6454, 6845, 6536, 6671, 6701, 5945, 6128, 6308, 5396]}, "law school rankings": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1041, 9060, 11680, 12021, 9058, 6391, 6186, 7715, 6739, 7135, 7303, 6817, 7161, 7099, 6346, 6463, 5105, 4303]}, "lord of the rings": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1722, 11197, 48239, 48952, 11212, 7395, 6475, 8439, 7908, 8058, 8178, 8356, 8141, 8401, 6695, 7438, 10773, 15081]}, "story of a girl": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2044, 10757, 52781, 53581, 10785, 7492, 7427, 8741, 8061, 8204, 8287, 8471, 8131, 8619, 7419, 8071, 10947, 15905]}, "to be or not to be": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2020, 22959, 63167, 63835, 22905, 18132, 16134, 20864, 18096, 18202, 18690, 17998, 18422, 18027, 16251, 18589, 16254, 14023]}, "arsenal player 1998 forward goal non flying dutch": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1450, 13119, 21449, 21778, 12525, 9031, 7797, 9552, 8468, 9285, 9702, 8889, 9278, 9105, 8234, 7855, 6378, 5430]}, "france president world war resistance london appeal": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1503, 18777, 33606, 33853, 18358, 13648, 10214, 12955, 11319, 12697, 13397, 11828, 12067, 11935, 10875, 10631, 8121, 6811]}, "pop singer songwriter born 1989 won best country song time person of year": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2745, 27476, 102310, 102762, 27977, 20007, 16102, 20608, 17811, 19558, 20557, 18734, 18994, 18354, 16953, 16703, 15029, 18132]}, "kenyan world marathon record olympic champion bbc world sport star of the year": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2773, 26486, 86825, 87731, 25739, 18061, 13920, 17906, 15945, 17338, 18199, 16592, 16510, 16498, 14381, 14634, 12552, 19092]}, "a search engine is an information retrieval software system designed to help find information stored on one or more computer systems": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [6016, 34277, 195304, 195798, 34025, 25666, 20424, 26235, 23635, 24820, 26016, 24772, 25128, 24293, 20280, 22688, 23128, 34381]}, "a database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure indexes are used to quickly locate data without having to search every row in a database table every time said table is accessed": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [11463, 55877, 322761, 324179, 56364, 42130, 32049, 43259, 39746, 42079, 43362, 41457, 42282, 40096, 33176, 37196, 38213, 61766]}, "what is the name of the chemist who fully developed the aquarium principle in 1850 explaining that plants added to water in a container would give off enough oxygen to support animals as long as the number of animals did not grow too large": {"dates": ["2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [40611, 39027, 54140]}}, "TOP_100_FILTER_80%": {"the": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1007, 6680, 34383, 34305, 7001, 4676, 4345, 5173, 4775, 5073, 4974, 5029, 5097, 5384, 4651, 5447, 5787, 5782]}, "search": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [577, 4249, 4172, 4499, 4744, 3314, 2720, 2909, 2791, 3077, 3220, 3053, 3218, 3105, 2886, 2776, 2881, 2958]}, "new york": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [979, 9297, 16419, 16993, 9407, 7151, 6196, 7841, 6833, 6859, 7461, 7158, 7413, 7457, 6510, 6863, 6715, 6194]}, "san francisco": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [778, 5642, 7269, 7391, 5726, 4230, 3548, 4233, 3846, 4052, 4245, 3957, 4285, 4302, 3755, 3683, 3693, 2509]}, "the who": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1379, 8956, 51871, 51451, 9113, 6358, 5825, 6917, 6817, 6864, 6967, 7044, 6431, 7036, 5995, 6129, 6386, 7960]}, "the incredibles": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1171, 7530, 39081, 39349, 7385, 5512, 4605, 5628, 5916, 5851, 6152, 5826, 5689, 6213, 5065, 4913, 4887, 5176]}, "new york population": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [982, 11096, 24734, 25095, 10879, 8381, 7274, 8815, 8143, 8265, 8473, 7997, 8703, 8536, 7374, 7778, 6709, 5110]}, "world bank president": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1008, 8482, 17597, 18035, 8738, 6681, 5936, 7401, 6416, 6622, 6774, 6333, 6701, 6655, 5970, 5968, 5404, 4277]}, "united states constitution": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1208, 7289, 15812, 16369, 7887, 5934, 5140, 6415, 5781, 5758, 6061, 5724, 6102, 5838, 5204, 5664, 5625, 4602]}, "law school rankings": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1016, 6688, 13498, 13850, 6609, 5034, 4675, 5657, 4988, 5190, 5182, 5056, 5411, 5385, 4666, 4562, 4961, 3886]}, "lord of the rings": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1870, 8754, 60293, 60505, 9171, 6462, 4745, 6817, 6204, 6493, 6785, 6470, 6567, 6881, 4992, 6105, 7289, 10775]}, "story of a girl": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1988, 10868, 64798, 65367, 10666, 8159, 6901, 8180, 7712, 7958, 8483, 7871, 8227, 8334, 7136, 7541, 7870, 9808]}, "to be or not to be": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2014, 25738, 72698, 72852, 25333, 20460, 17875, 23222, 19832, 20480, 20609, 19637, 20544, 20401, 18241, 20566, 19157, 17024]}, "arsenal player 1998 forward goal non flying dutch": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1337, 12688, 23219, 23675, 12559, 9103, 7880, 9388, 8494, 9290, 9572, 8881, 9274, 9326, 8075, 7957, 6256, 4837]}, "france president world war resistance london appeal": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [1483, 17046, 36237, 37250, 17289, 12966, 10622, 13120, 11252, 12418, 12916, 11754, 12175, 12153, 10808, 10757, 7890, 6259]}, "pop singer songwriter born 1989 won best country song time person of year": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2958, 24115, 113198, 114085, 25181, 19193, 15270, 20286, 17441, 18946, 19453, 17988, 18184, 18265, 15764, 17204, 13765, 12457]}, "kenyan world marathon record olympic champion bbc world sport star of the year": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [2846, 22196, 99574, 99918, 22213, 16371, 13250, 16761, 15209, 16123, 17103, 15462, 15852, 16007, 13440, 13655, 11851, 10932]}, "a search engine is an information retrieval software system designed to help find information stored on one or more computer systems": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [6010, 32095, 208489, 208811, 32614, 24679, 19852, 25962, 23641, 25152, 25708, 24373, 24467, 24092, 19260, 22839, 21207, 21376]}, "a database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure indexes are used to quickly locate data without having to search every row in a database table every time said table is accessed": {"dates": ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [12258, 51864, 334744, 336055, 53709, 41029, 30515, 42350, 38743, 40423, 42152, 40321, 40142, 40013, 31838, 36636, 35133, 36286]}, "what is the name of the chemist who fully developed the aquarium principle in 1850 explaining that plants added to water in a container would give off enough oxygen to support animals as long as the number of animals did not grow too large": {"dates": ["2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"], "latencies": [44854, 38496, 34583]}}};
        const resultTypes = ["TOP_10", "TOP_100", "TOP_1000", "TOP_100_FILTER_20%", "TOP_100_FILTER_5%", "TOP_100_FILTER_80%"];
        const defaultResultType = "TOP_10";
        const dateAnnotations = {"2025-11-22T11:01:12": {"text": "Made block postings generic over weight", "pr": 5995}, "2025-11-23T11:42:28": {"text": "Inlined decoding of weights", "pr": 6043}};
        const chartInstances = {};
        
        // Handle radio button changes
        document.querySelectorAll('input[name="resultType"]').forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked) {
                    const selectedType = this.value;
                    updateCharts(selectedType);
                }
            });
        });
        
        function updateCharts(resultType) {
            const chartData = allChartData[resultType];
            if (!chartData) return;
            
            // Update each chart
            Object.keys(chartInstances).forEach(chartId => {
                const instance = chartInstances[chartId];
                if (!instance) return;
                
                const query = instance.config.data.datasets[0]._query;
                if (chartData[query]) {
                    const data = chartData[query];
                    instance.data.labels = data.dates;
                    instance.data.datasets[0].data = data.latencies;
                    
                    // Update annotations based on new dates
                    const newAnnotations = [];
                    data.dates.forEach((dateStr, idx) => {
                        if (dateAnnotations[dateStr]) {
                            const annInfo = dateAnnotations[dateStr];
                            newAnnotations.push({
                                x: idx,
                                text: annInfo.text || '',
                                pr: annInfo.pr
                            });
                        }
                    });
                    
                    // Update annotation plugin configuration
                    if (instance.options.plugins && instance.options.plugins.annotation) {
                        const annotationConfig = {
                            annotations: {}
                        };
                        
                        newAnnotations.forEach((ann, idx) => {
                            const annotationKey = `annotation_${idx}`;
                            const isEven = idx % 2 === 0;
                            const position = isEven ? 'start' : 'end';
                            const baseOffset = isEven ? -6 : 6;
                            const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                            const yAdjust = baseOffset + staggerOffset;
                            
                            let labelText = ann.text;
                            if (ann.pr) {
                                labelText += ' #' + ann.pr;
                            }
                            
                            annotationConfig.annotations[annotationKey] = {
                                type: 'line',
                                xMin: ann.x,
                                xMax: ann.x,
                                borderColor: 'rgb(255, 99, 132)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                label: {
                                    display: true,
                                    content: labelText,
                                    position: position,
                                    backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                                    color: 'white',
                                    font: {
                                        size: 10,
                                        weight: 'bold'
                                    },
                                    padding: {
                                        top: 2,
                                        bottom: 2,
                                        left: 4,
                                        right: 4
                                    },
                                    xAdjust: 0,
                                    yAdjust: yAdjust
                                }
                            };
                        });
                        
                        instance.options.plugins.annotation = annotationConfig;
                    }
                    
                    instance.update('none'); // Update without animation
                }
            });
        }
    </script>

        <div class="chart-container">
            <div class="chart-title">Query: "the"</div>
            <div class="chart-wrapper">
                <canvas id="chart_385910"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>2168.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>16066.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>4272.19 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_385910').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [4124, 2910, 3040, 2580, 3676, 16066, 15998, 3849, 2797, 2168, 2755, 2843, 2835, 2966, 2741, 2978, 2994, 2532, 3224, 3425, 3215];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "the"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_385910'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_385910');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_385910');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_385910');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "search"</div>
            <div class="chart-wrapper">
                <canvas id="chart_659790"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>765.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>2019.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>1087.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_659790').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [1235, 794, 1318, 765, 1355, 1966, 2019, 1230, 783, 906, 870, 937, 924, 916, 1025, 956, 942, 897, 999, 968, 1022];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "search"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_659790'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_659790');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_659790');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_659790');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "new york"</div>
            <div class="chart-wrapper">
                <canvas id="chart_480262"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>2259.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>10213.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>3587.05 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_480262').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [3335, 2259, 3016, 2635, 3415, 10213, 10046, 3504, 2733, 2439, 3113, 2833, 2724, 2721, 3016, 2958, 2951, 2599, 3059, 2977, 2782];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "new york"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_480262'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_480262');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_480262');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_480262');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "san francisco"</div>
            <div class="chart-wrapper">
                <canvas id="chart_359197"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>1323.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>4356.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>1860.52 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_359197').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [1958, 1323, 1899, 1405, 1879, 4356, 4317, 1859, 1395, 1483, 1627, 1519, 1524, 1554, 1646, 1571, 1595, 1539, 1552, 1518, 1552];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "san francisco"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_359197'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_359197');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_359197');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_359197');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "the who"</div>
            <div class="chart-wrapper">
                <canvas id="chart_368523"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>2715.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>32662.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>6283.81 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_368523').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [4362, 3040, 3079, 3352, 4266, 32579, 32662, 4787, 3414, 2715, 3870, 3416, 3442, 3586, 3519, 3461, 3191, 2793, 3815, 3266, 3345];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "the who"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_368523'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_368523');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_368523');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_368523');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "the incredibles"</div>
            <div class="chart-wrapper">
                <canvas id="chart_432151"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>1505.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>20900.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>3908.14 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_432151').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [2629, 1505, 2071, 1804, 3179, 20900, 20540, 3249, 1886, 1585, 2159, 2165, 2132, 2252, 2336, 2179, 2216, 1829, 1768, 1892, 1795];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "the incredibles"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_432151'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_432151');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_432151');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_432151');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "new york population"</div>
            <div class="chart-wrapper">
                <canvas id="chart_242437"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>4023.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>17667.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>5798.86 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_242437').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [5666, 4023, 5532, 4065, 5617, 17447, 17667, 5539, 4222, 4069, 4944, 4196, 4468, 4322, 4304, 4507, 4528, 4048, 4241, 4342, 4029];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "new york population"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_242437'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_242437');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_242437');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_242437');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "world bank president"</div>
            <div class="chart-wrapper">
                <canvas id="chart_115099"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>2598.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>12038.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>4053.48 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_115099').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [3912, 2598, 3604, 3031, 3754, 11705, 12038, 3916, 3016, 2981, 3685, 3287, 3151, 3276, 3238, 3076, 3091, 2914, 3006, 3130, 2714];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "world bank president"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_115099'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_115099');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_115099');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_115099');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "united states constitution"</div>
            <div class="chart-wrapper">
                <canvas id="chart_478895"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>2495.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>10955.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>3780.14 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_478895').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [3513, 2495, 2947, 2855, 3251, 10733, 10955, 3395, 2954, 2713, 3323, 3089, 3052, 3126, 3179, 3087, 2889, 2591, 2957, 2950, 3329];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "united states constitution"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_478895'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_478895');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_478895');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_478895');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "law school rankings"</div>
            <div class="chart-wrapper">
                <canvas id="chart_424445"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>1756.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>8634.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>2842.72 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>18</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_424445').getContext('2d');
                const dates = ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [1806, 2698, 8634, 8455, 2519, 1928, 1818, 2374, 1972, 2101, 2090, 2154, 2118, 2130, 1756, 2002, 2250, 2364];
                const annotations = [{"x": 2, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 4, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "law school rankings"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_424445'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_424445');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_424445');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_424445');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "lord of the rings"</div>
            <div class="chart-wrapper">
                <canvas id="chart_482806"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>2074.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>41259.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>6759.57 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_482806').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [4323, 2846, 3346, 2701, 4154, 41239, 41259, 4444, 2889, 2074, 2920, 3025, 2866, 2895, 2954, 2966, 3136, 2158, 2900, 2944, 3912];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "lord of the rings"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_482806'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_482806');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_482806');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_482806');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "story of a girl"</div>
            <div class="chart-wrapper">
                <canvas id="chart_506162"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>3326.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>46318.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>8037.81 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_506162').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [4813, 3363, 4855, 3720, 4876, 46095, 46318, 5051, 3689, 3326, 3938, 3806, 3863, 3396, 3778, 3854, 4062, 3482, 3753, 3893, 4863];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "story of a girl"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_506162'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_506162');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_506162');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_506162');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "to be or not to be"</div>
            <div class="chart-wrapper">
                <canvas id="chart_970836"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>11825.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>57464.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>18608.72 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>18</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_970836').getContext('2d');
                const dates = ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [13179, 16252, 57275, 57464, 16189, 13153, 11825, 15282, 13353, 13690, 13590, 13738, 13755, 13353, 11927, 13767, 13722, 13443];
                const annotations = [{"x": 2, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 4, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "to be or not to be"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_970836'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_970836');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_970836');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_970836');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "arsenal player 1998 forward goal non flying dutch"</div>
            <div class="chart-wrapper">
                <canvas id="chart_133310"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>3684.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>18399.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>6599.90 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_133310').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [6750, 4625, 6476, 5352, 6831, 18104, 18399, 7002, 5078, 4710, 5694, 5070, 5502, 5783, 5335, 5363, 5317, 4895, 4859, 3769, 3684];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "arsenal player 1998 forward goal non flying dutch"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_133310'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_133310');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_133310');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_133310');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "france president world war resistance london appeal"</div>
            <div class="chart-wrapper">
                <canvas id="chart_380309"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>4562.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>29967.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>9693.14 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_380309').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [9962, 6718, 9451, 7514, 9523, 29470, 29967, 9942, 7483, 6878, 8186, 7346, 7831, 7811, 7382, 7668, 7357, 6791, 6930, 4784, 4562];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "france president world war resistance london appeal"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_380309'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_380309');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_380309');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_380309');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "pop singer songwriter born 1989 won best country song time person of year"</div>
            <div class="chart-wrapper">
                <canvas id="chart_521966"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>8570.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>95717.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>20115.38 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_521966').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [14893, 11039, 14401, 12618, 15418, 95453, 95717, 15478, 12088, 10183, 12593, 12036, 12769, 12875, 12095, 12154, 11748, 10427, 11045, 8823, 8570];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "pop singer songwriter born 1989 won best country song time person of year"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_521966'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_521966');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_521966');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_521966');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "kenyan world marathon record olympic champion bbc world sport star of the year"</div>
            <div class="chart-wrapper">
                <canvas id="chart_443357"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>6568.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>80657.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>15402.67 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_443357').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [10682, 6897, 9560, 8398, 10467, 79505, 80657, 11735, 8270, 7320, 8703, 8399, 9052, 8908, 9021, 8699, 8373, 7277, 8014, 6951, 6568];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "kenyan world marathon record olympic champion bbc world sport star of the year"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_443357'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_443357');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_443357');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_443357');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "a search engine is an information retrieval software system designed to help find information stored on one or more computer systems"</div>
            <div class="chart-wrapper">
                <canvas id="chart_419159"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>10976.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>188656.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>30762.76 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>21</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_419159').getContext('2d');
                const dates = ["2025-11-20T10:34:44", "2025-11-20T13:01:23", "2025-11-20T19:48:51", "2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [17648, 12904, 16963, 14451, 19243, 188223, 188656, 18818, 14021, 11297, 14169, 13614, 13765, 13731, 12713, 14201, 13573, 10976, 12794, 11923, 12335];
                const annotations = [{"x": 5, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 7, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "a search engine is an information retrieval software system designed to help find information stored on one or more computer systems"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_419159'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_419159');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_419159');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_419159');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "what is the name of the chemist who fully developed the aquarium principle in 1850 explaining that plants added to water in a container would give off enough oxygen to support animals as long as the number of animals did not grow too large"</div>
            <div class="chart-wrapper">
                <canvas id="chart_534081"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>23222.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>30014.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>25935.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>3</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_534081').getContext('2d');
                const dates = ["2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [30014, 24569, 23222];
                const annotations = [];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "what is the name of the chemist who fully developed the aquarium principle in 1850 explaining that plants added to water in a container would give off enough oxygen to support animals as long as the number of animals did not grow too large"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_534081'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_534081');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_534081');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_534081');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

        <div class="chart-container">
            <div class="chart-title">Query: "a database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure indexes are used to quickly locate data without having to search every row in a database table every time said table is accessed"</div>
            <div class="chart-wrapper">
                <canvas id="chart_187426"></canvas>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Min:</span>
                    <span>17638.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max:</span>
                    <span>314950.00 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg:</span>
                    <span>56645.67 ms</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Data Points:</span>
                    <span>18</span>
                </div>
            </div>
        </div>
        
        <script>
            (function() {
                const ctx = document.getElementById('chart_187426').getContext('2d');
                const dates = ["2025-11-21T10:47:25", "2025-11-21T13:37:06", "2025-11-22T11:01:12", "2025-11-22T14:56:15", "2025-11-23T11:42:28", "2025-11-24T20:26:35", "2025-11-25T10:56:40", "2025-11-26T10:52:43", "2025-11-27T10:54:40", "2025-11-28T10:53:02", "2025-11-29T10:53:49", "2025-11-30T10:52:49", "2025-12-01T10:55:00", "2025-12-02T10:56:00", "2025-12-03T10:54:28", "2025-12-10T17:10:43", "2025-12-11T10:52:02", "2025-12-12T10:51:19"];
                const latencies = [25013, 32791, 312949, 314950, 35143, 25914, 17708, 24957, 24191, 25536, 24614, 25117, 24999, 24628, 17638, 21717, 20802, 20955];
                const annotations = [{"x": 2, "text": "Made block postings generic over weight", "pr": 5995}, {"x": 4, "text": "Inlined decoding of weights", "pr": 6043}];
                
                // Build annotation configuration
                const annotationConfig = {
                    annotations: {}
                };
                
                // Add vertical line annotations for each annotated date
                // Use staggered vertical positions to prevent overlap
                annotations.forEach((ann, idx) => {
                    const annotationKey = `annotation_${idx}`;
                    // Build compact label text with optional PR link indicator
                    let labelText = ann.text;
                    if (ann.pr) {
                        labelText += ' #' + ann.pr;
                    }
                    
                    // Stagger labels vertically: alternate between top and bottom, with slight offsets
                    const isEven = idx % 2 === 0;
                    const position = isEven ? 'start' : 'end';
                    // Use different yAdjust values to create staggered effect
                    const baseOffset = isEven ? -6 : 6;
                    const staggerOffset = (idx % 4 < 2) ? 0 : (isEven ? -12 : 12);
                    const yAdjust = baseOffset + staggerOffset;
                    
                    annotationConfig.annotations[annotationKey] = {
                        type: 'line',
                        xMin: ann.x,
                        xMax: ann.x,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: labelText,
                            position: position,
                            backgroundColor: ann.pr ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.8)',
                            color: 'white',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 4,
                                right: 4
                            },
                            xAdjust: 0,
                            yAdjust: yAdjust,
                            // Store PR number for click handler
                            _pr: ann.pr
                        },
                        // Store annotation index and PR for click handling
                        _annIndex: idx,
                        _pr: ann.pr
                    };
                });
                
                // Store chart reference for click handling
                let chartInstance = null;
                
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: latencies,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            _query: "a database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure indexes are used to quickly locate data without having to search every row in a database table every time said table is accessed"
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        const dateLabel = context[0].label;
                                        const annotation = annotations.find(a => dates[a.x] === dateLabel);
                                        if (annotation) {
                                            let tooltipText = 'Date: ' + dateLabel + ' [' + annotation.text + ']';
                                            if (annotation.pr) {
                                                tooltipText += ' (PR #' + annotation.pr + ')';
                                            }
                                            return tooltipText;
                                        }
                                        return 'Date: ' + dateLabel;
                                    },
                                    label: function(context) {
                                        return 'Latency: ' + context.parsed.y.toFixed(2) + ' ms';
                                    }
                                }
                            },
                            annotation: annotationConfig,
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    modifierKey: null
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false
                                    },
                                    pinch: {
                                        enabled: false
                                    },
                                    drag: {
                                        enabled: true,
                                        modifierKey: null,
                                        backgroundColor: 'rgba(225, 225, 225, 0.3)',
                                        borderColor: 'rgba(225, 225, 225, 0.8)',
                                        borderWidth: 1
                                    },
                                    mode: 'x'
                                },
                                limits: {
                                    x: {min: 'original', max: 'original'},
                                    y: {min: 'original', max: 'original'}
                                }
                            }
                        },
                        onClick: function(event, elements) {
                            // Check if click is near an annotation
                            if (!chartInstance) return;
                            
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                            const xScale = chartInstance.scales.x;
                            const xValue = xScale.getValueForPixel(canvasPosition.x);
                            
                            // Find closest annotation
                            let closestAnn = null;
                            let minDist = Infinity;
                            annotations.forEach(ann => {
                                const dist = Math.abs(ann.x - xValue);
                                if (dist < minDist && dist < 0.5) {
                                    minDist = dist;
                                    closestAnn = ann;
                                }
                            });
                            
                            // If clicked on annotation with PR, open PR link
                            if (closestAnn && closestAnn.pr) {
                                window.open('https://github.com/turbopuffer/turbopuffer/pull/' + closestAnn.pr, '_blank');
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Latency (ms)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                
                // Store chart instance for result type switching
                chartInstances['chart_187426'] = chartInstance;
                
                // Enable zoom event handlers
                try {
                    chartInstance.on('zoom', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_187426');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                    
                    chartInstance.on('pan', function() {
                        const resetBtn = document.getElementById('resetZoom_chart_187426');
                        if (resetBtn) {
                            resetBtn.disabled = false;
                        }
                    });
                } catch(e) {
                    // Zoom events might not be available, that's OK
                }
                
                // Make canvas cursor pointer when hovering over annotations with PRs
                const canvas = document.getElementById('chart_187426');
                canvas.addEventListener('mousemove', function(event) {
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
                    const xScale = chartInstance.scales.x;
                    const xValue = xScale.getValueForPixel(canvasPosition.x);
                    
                    // Check if mouse is near an annotation with PR
                    let nearAnnotationWithPR = false;
                    annotations.forEach(ann => {
                        if (Math.abs(ann.x - xValue) < 0.5 && ann.pr) {
                            nearAnnotationWithPR = true;
                        }
                    });
                    canvas.style.cursor = nearAnnotationWithPR ? 'pointer' : 'default';
                });
            })();
        </script>

    <script>
        function resetZoom(chartId) {
            const chartInstance = chartInstances[chartId];
            if (chartInstance && typeof chartInstance.resetZoom === 'function') {
                chartInstance.resetZoom();
                const resetBtn = document.getElementById('resetZoom_' + chartId);
                if (resetBtn) {
                    resetBtn.disabled = true;
                }
            }
        }
    </script>

    </div>
</body>
</html>
